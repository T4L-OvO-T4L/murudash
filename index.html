<!DOCTYPE html>
<html lang="ja">
<head>

<!-- ğŸ”’ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ– -->
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://cdn.tailwindcss.com 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; img-src 'self' data:; media-src 'self';">
<meta name="referrer" content="strict-origin-when-cross-origin">

<link rel="preload" as="image" href="./assets/blueberry.svg">
<link rel="preload" as="image" href="./assets/sunflower.svg">
<link rel="preload" as="audio" href="./assets/BGM.mp3">
<link rel="preload" as="audio" href="./assets/END.mp3">

<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>ã‚€ã‚‹ã ã£ã—ã‚…ï¼</title>

<script src="https://cdn.tailwindcss.com"></script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
  body {
    font-family: 'Inter', sans-serif;
    touch-action: manipulation;
    overflow: hidden;
    overscroll-behavior: none;
    background-color: #1a202c;
  }
  canvas { display: block; }
  .control-button { transition: background-color 0.1s ease, transform 0.1s ease; }
  .control-button:active { transform: scale(0.95); background-color: #2c5282; }
  .pause-button { transition: background-color 0.1s ease, transform 0.1s ease; }
  .pause-button:active { transform: scale(0.95); }
</style>
</head>
<body class="bg-gray-800 flex flex-col items-center justify-start min-h-screen pt-3 sm:pt-4 pb-28">

  <!-- éå…¬å¼æ³¨è¨˜ -->
  <div class="w-full text-center bg-gray-900 text-gray-300 text-[11px] py-1 shadow-md">
    â€»æœ¬ä½œå“ã¯
    <a href="https://kuronekotsuki.booth.pm/items/4672957" target="_blank" rel="noopener noreferrer" class="underline hover:text-white transition">ï½¢ãƒ ãƒ«ãƒ«ï½£</a>
    ã‚’ãƒ¢ãƒãƒ¼ãƒ•ã«ã—ãŸéå…¬å¼ãƒ•ã‚¡ãƒ³ä½œå“ã§ã™ã€‚<br class="sm:hidden">
    æ¨©åˆ©è€…æ§˜ã¨ã¯ä¸€åˆ‡é–¢ä¿‚ã‚ã‚Šã¾ã›ã‚“ã€‚<br>
    â€»éŸ³ãŒå‡ºã¾ã™ã€‚ã”æ³¨æ„ãã ã•ã„ã€‚<br>
    â€»iOS Safariæƒ³å®šã®è¨­è¨ˆã§ã™ã€‚ä»–ã®ç«¯æœ«ã§ã‚‚éŠã¹ã¾ã™ãŒã€ç–‘æƒ‘ã®åˆ¤å®šãŒç”Ÿã¾ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚
  </div>

  <!-- ãƒ˜ãƒƒãƒ€ãƒ¼ -->
  <div class="w-full max-w-lg p-3 bg-white rounded-t-lg shadow-md">
    <div class="flex items-center justify-between gap-3">
      <div class="text-left">
        <span class="text-xl sm:text-2xl font-bold text-blue-600">
          ã‚¹ã‚³ã‚¢: <span id="score" class="inline-block min-w-[60px] text-right font-mono">0</span>
        </span>
      </div>
      <div class="flex items-center gap-3 shrink-0">
        <span id="highScore" class="text-xs text-gray-500 block">ãƒã‚¤ã‚¹ã‚³ã‚¢: 0</span>
        <button id="pauseButton" class="pause-button px-3 py-2 sm:px-4 sm:py-2 bg-yellow-500 text-white font-bold rounded-lg shadow-md text-sm">
          ã¡ã‚‡ã£ã¨ä¼‘æ†©
        </button>
      </div>
    </div>
  </div>

  <!-- ã‚­ãƒ£ãƒ³ãƒã‚¹ -->
  <div class="relative w-full max-w-lg mt-2 mb-24">
    <canvas id="gameCanvas" class="rounded-b-lg shadow-md"></canvas>

    <!-- ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ -->
    <div id="startScreen" class="absolute inset-0 bg-black bg-opacity-70 flex-col justify-center items-center rounded-b-lg text-white p-8 text-center flex">
      <h2 class="text-5xl font-bold mb-6">ã‚€ã‚‹ã ã£ã—ã‚…ï¼</h2>
      <p class="text-lg mb-4">ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ã‚¸ãƒ£ãƒ³ãƒ—ï¼<br>ç©ºä¸­ã§ã‚‚ã†ä¸€å›ã§2æ®µã‚¸ãƒ£ãƒ³ãƒ—ï¼</p>
      <p class="text-lg mb-8">éšœå®³ç‰©ã‚’ã‚ˆã‘ã¾ãã‚ã†ï¼</p>
      <button id="startButton" class="px-8 py-4 bg-green-600 text-white font-bold rounded-lg shadow-lg text-2xl hover:bg-green-700 transition-colors">
        ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆ
      </button>
    </div>

    <!-- ãƒãƒ¼ã‚º -->
    <div id="pauseOverlay" class="absolute inset-0 bg-black bg-opacity-50 flex-col justify-center items-center rounded-b-lg text-white p-8 text-center hidden">
      <h2 class="text-4xl font-bold mb-4">ä¸€æ™‚åœæ­¢ä¸­</h2>
      <p class="text-xl">(ã€Œã¡ã‚‡ã£ã¨ä¼‘æ†©ã€ãƒœã‚¿ãƒ³ã§å†é–‹)</p>
    </div>

    <!-- ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ -->
    <div id="gameOverScreen" class="absolute inset-0 bg-black bg-opacity-50 flex-col justify-center items-center rounded-lg text-white p-8 text-center hidden">
      <h2 class="text-4xl font-bold mb-4">ãŒã‚ãŠã¹ã‚‰</h2>
      <p class="text-xl mb-6">ã‚¹ã‚³ã‚¢: <span id="finalScore">0</span></p>

      <div class="flex flex-wrap justify-center gap-3">
        <button id="restartButton"
          class="px-8 py-4 bg-blue-600 text-white font-bold rounded-lg shadow-lg text-xl hover:bg-blue-700 transition-colors">
          ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ
        </button>

        <a id="shareButton"
          href="#"
          target="_blank" rel="noopener noreferrer"
          class="px-8 py-4 bg-black text-white font-bold rounded-lg shadow-lg text-xl hover:bg-gray-900 transition-colors">
          Xã§ã‚¹ã‚³ã‚¢ã‚’ã‚·ã‚§ã‚¢
        </a>
      </div>
    </div>
  </div>

  <!-- ã‚¸ãƒ£ãƒ³ãƒ—ãƒœã‚¿ãƒ³ -->
  <div class="w-full max-w-lg flex justify-center p-4 fixed bottom-0 left-1/2 -translate-x-1/2">
    <button id="jumpButton" class="control-button w-full py-12 bg-blue-600 text-white font-bold rounded-lg shadow-lg text-2xl">
      ã‚¸ãƒ£ãƒ³ãƒ—
    </button>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const highScoreEl = document.getElementById('highScore');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const finalScoreEl = document.getElementById('finalScore');
    const restartButton = document.getElementById('restartButton');
    const shareButton = document.getElementById('shareButton');

    const jumpButton = document.getElementById('jumpButton');
    const pauseButton = document.getElementById('pauseButton');
    const pauseOverlay = document.getElementById('pauseOverlay');
    const startScreen = document.getElementById('startScreen');
    const startButton = document.getElementById('startButton');

    // ç”»åƒ
    function loadImg(src) { const img = new Image(); img.src = src; return img; }
    const SPRITES = {
      blueberry: loadImg('./assets/blueberry.svg'),
      sunflower: loadImg('./assets/sunflower.svg')
    };

    // éŸ³
    let audioStarted = false;
    let bgmAudio, endAudio;
    async function startAudio() {
      if (audioStarted) return;
      try {
        bgmAudio = new Audio('./assets/BGM.mp3'); bgmAudio.loop = true; bgmAudio.volume = 0.5; await bgmAudio.play();
        endAudio = new Audio('./assets/END.mp3'); endAudio.volume = 0.5;
        audioStarted = true;
      } catch (e) { console.error(e); }
    }

    // ç”»é¢ã‚µã‚¤ã‚º
    const parentWidth = canvas.parentElement.clientWidth;
    const gameWidth = Math.min(parentWidth, 768);
    const gameHeight = 300;
    canvas.width = gameWidth; canvas.height = gameHeight;

    // ===== ç©ºã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å®šç¾© =====
    const THEMES = {
      morning: { top: [160,210,235], bottom: [247,250,252] },
      evening: { top: [246,173, 85], bottom: [253,230,138] },
      night:   { top: [45, 55, 90], bottom: [20, 25, 50] },
    };
    let skyCurrent = { top: [...THEMES.morning.top], bottom: [...THEMES.morning.bottom] };
    let skyTarget  = { top: [...THEMES.morning.top], bottom: [...THEMES.morning.bottom] };
    const skyLerpSpeed = 0.03;
    function setBackgroundTheme(theme){ const t = THEMES[theme] || THEMES.morning; skyTarget = { top:[...t.top], bottom:[...t.bottom] }; }

    // âœ… ãƒ•ã‚§ãƒ¼ã‚ºã‚’é…åˆ—ã§ç®¡ç†ï¼ˆå¤•â†’å¤œâ†’å¤•â†’æœã®å·¡å›ã‚’ç¢ºå®Ÿã«å›ã™ï¼‰
    const PHASES = [
      { name:'morning',  theme:'morning', duration: 95*1000 },
      { name:'evening1', theme:'evening', duration:139*1000 },
      { name:'night',    theme:'night',   duration: 95*1000 },
      { name:'evening2', theme:'evening', duration:139*1000 },
    ];
    let phaseIndex = 0;
    let phaseElapsed = 0;
    let phaseName = PHASES[0].name;

    function enterPhase(i){
      phaseIndex = (i + PHASES.length) % PHASES.length;
      phaseElapsed = 0;
      phaseName = PHASES[phaseIndex].name;
      setBackgroundTheme(PHASES[phaseIndex].theme);
    }
    function updatePhase(deltaMs){
      phaseElapsed += deltaMs;
      while (phaseElapsed >= PHASES[phaseIndex].duration) {
        phaseElapsed -= PHASES[phaseIndex].duration;
        enterPhase(phaseIndex + 1);
      }
    }

    function lerp(a,b,t){ return a+(b-a)*t; }
    function stepRGB(cur,tgt,t){ return [0,1,2].map(i=>lerp(cur[i],tgt[i],t)); }
    function drawSky(deltaFactor){
      const t=Math.min(1,skyLerpSpeed*deltaFactor);
      skyCurrent.top=stepRGB(skyCurrent.top,skyTarget.top,t);
      skyCurrent.bottom=stepRGB(skyCurrent.bottom,skyTarget.bottom,t);
      const g=ctx.createLinearGradient(0,0,0,gameHeight);
      const top=`rgb(${skyCurrent.top.map(x=>x|0).join(',')})`;
      const bottom=`rgb(${skyCurrent.bottom.map(x=>x|0).join(',')})`;
      g.addColorStop(0,top); g.addColorStop(0.8,bottom);
      ctx.fillStyle=g; ctx.fillRect(0,0,gameWidth,gameHeight);
    }
    // åˆæœŸãƒ•ã‚§ãƒ¼ã‚º
    enterPhase(0);

    // é›²
    let clouds = Array.from({ length: 5 }, () => ({
      x: Math.random() * gameWidth,
      y: 40 + Math.random() * 90,
      speed: 0.12 + Math.random() * 0.18,
      size: 60 + Math.random() * 60
    }));
    function drawClouds(deltaFactor) {
      // âœ… å¤œåˆ¤å®šã¯ãƒ•ã‚§ãƒ¼ã‚ºåã§
      const isNight = (phaseName === 'night');
      const alpha = isNight ? 0.35 : 0.45;
      ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
      for (let c of clouds) {
        c.x -= c.speed * deltaFactor;
        if (c.x < -200) c.x = gameWidth + 100;
        ctx.beginPath();
        ctx.ellipse(c.x, c.y, c.size, c.size * 0.6, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(c.x + c.size * 0.6, c.y + 10, c.size * 0.9, c.size * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // ====== ã‚²ãƒ¼ãƒ çŠ¶æ…‹ ======
    let score=0, highScore=localStorage.getItem('muruHighScore')||0;
    highScoreEl.textContent=`ãƒã‚¤ã‚¹ã‚³ã‚¢: ${highScore}`;
    let gameSpeed=5, baseGameSpeed=5, gameSpeedAcceleration=0.05;

    let timeElapsed=0, obstacles=[], frame=0, spawnTimer=0;

    // â˜… æ¹§ããƒ™ãƒ¼ã‚¹é–“éš”ï¼ˆå‰å›ã‚ˆã‚Šå°‘ã—è©°ã‚ã‚‹ï¼‰
    const minSpawnIntervalBase=120, maxSpawnIntervalBase=170, spawnIntervalReductionPerSec=3;

    // â˜… åºç›¤ã‚†ã‚‹ã‚ï¼šå¼±ã‚ã«ï¼ˆ1.25å€ â†’ 25ç§’ã§é€šå¸¸ã¸ï¼‰
    const EARLY_EASE_MS = 25_000;
    const EARLY_EASE_START_MULT = 1.25;

    // â˜… åºç›¤ æœ€å¤§åŒæ™‚æ•°ï¼š4å€‹ã¾ã§ï¼ˆå‰å›3â†’4ã§â€œå°‘ãªã™ãâ€è§£æ¶ˆï¼‰
    const EARLY_MAX_ONSCREEN_OBS_MS = 20_000;
    const EARLY_MAX_ONSCREEN_OBS = 4;

    let isGameOver = false, isPaused = false, gameStarted = false, lastTime = 0;
    const baseDeltaTime=1000/60;
    const groundY=gameHeight-50;

    let isDebug = false;
    let debugTapCount = 0;

    let nextSpawnInterval = 90;

    // ãƒ˜ãƒ«ãƒ‘ãƒ¼
    function clamp01(v){ return Math.max(0, Math.min(1, v)); }
    function getEarlyEaseMultiplier(ms){
      const t = clamp01(ms / EARLY_EASE_MS);
      return EARLY_EASE_START_MULT + (1.0 - EARLY_EASE_START_MULT) * t;
    }
    function getMinPixelGap(ms){
      // ç›´å¾Œæ¹§ãé˜²æ­¢ï¼šåºç›¤ã¡ã‚‡ã„åºƒã‚â†’é€šå¸¸ã¸
      const t = clamp01(ms / EARLY_EASE_MS);
      const start = 240, end = 170;
      return Math.round(start + (end - start) * t);
    }

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
    const player={x:50,y:groundY-50,width:50,height:50,dy:0,gravity:0.8,jumpForce:15,isGrounded:true,jumpsRemaining:2,isJumping:false,image:new Image(),imageLoaded:false};
    player.image.src='./assets/Muru.png';
    player.image.onload=()=>{player.imageLoaded=true;player.width=(player.image.width/player.image.height)*player.height;};

    function drawPlayer(){ if(player.imageLoaded)ctx.drawImage(player.image,player.x,player.y,player.width,player.height); else{ctx.fillStyle='green';ctx.fillRect(player.x,player.y,player.width,player.height);} }
    function updatePlayer(d){
      if(!player.isGrounded){player.dy+=player.gravity*d;player.y+=player.dy*d;}
      if(player.y+player.height>=groundY){player.y=groundY-player.height;player.dy=0;player.isGrounded=true;player.jumpsRemaining=2;}
    }
    function playerJump(){ startAudio(); if(isGameOver||isPaused||!gameStarted)return; if(player.jumpsRemaining>0){player.dy=-player.jumpForce;player.isGrounded=false;player.isJumping=true;player.jumpsRemaining--;}}
    function stopJump(){ if(player.isJumping&&player.dy<0){player.dy=Math.max(player.dy,-5);} player.isJumping=false; }

    // éšœå®³ç‰©
    class Obstacle {
      constructor(type, img, y, size) {
        this.x = gameWidth;
        this.y = y;
        this.type = type;
        this.img = img;
        this.height = size;
        const iw = img.naturalWidth || 1;
        const ih = img.naturalHeight || 1;
        const aspect = iw / ih;
        this.width = this.height * aspect;
        this.passed = false;
      }
      draw() { ctx.drawImage(this.img, this.x, this.y - this.height, this.width, this.height); }
      update(d) { this.x -= gameSpeed * d; }
      getHitbox() {
        const shrink = this.type === 'ground_large' ? 0.65 : 0.8;
        const w = this.width * shrink, h = this.height * shrink;
        return { x: this.x + (this.width - w) / 2, y: (this.y - this.height) + (this.height - h) / 2, width: w, height: h };
      }
    }

    const SCALE = 0.7;
    function spawnObstacle(delta) {
      spawnTimer += delta;

      // æ™‚é–“çµŒéã§å°‘ã—ãšã¤çŸ­ãï¼ˆç·©ã‚ï¼‰
      let minSpawnInterval = Math.max(minSpawnIntervalBase - (timeElapsed / 1000) * spawnIntervalReductionPerSec, 40);
      let maxSpawnInterval = Math.max(maxSpawnIntervalBase - (timeElapsed / 1000) * spawnIntervalReductionPerSec, 70);

      // åºç›¤ã‚†ã‚‹ã‚å€ç‡ï¼ˆå¼±ï¼‰ã‚’æ›ã‘ã‚‹
      const easeMul = getEarlyEaseMultiplier(timeElapsed);
      minSpawnInterval *= easeMul;
      maxSpawnInterval *= easeMul;

      // ã¾ã æ¹§ã‹ã›ãªã„
      if (spawnTimer < nextSpawnInterval) return;

      // åºç›¤ã®ç”»é¢å†…ä¸Šé™
      if (timeElapsed < EARLY_MAX_ONSCREEN_OBS_MS) {
        const onscreen = obstacles.filter(o => o.x + o.width > 0).length;
        if (onscreen >= EARLY_MAX_ONSCREEN_OBS) return;
      }

      // ç›´å‰ã¨ã®ãƒ”ã‚¯ã‚»ãƒ«è·é›¢ãƒã‚§ãƒƒã‚¯ã§è©°ã¾ã‚Šå›é¿
      const last = obstacles.length ? obstacles[obstacles.length - 1] : null;
      const minGapPx = getMinPixelGap(timeElapsed);
      if (last) {
        const gapPx = gameWidth - (last.x + last.width);
        if (gapPx < minGapPx) return;
      }

      // å‡ºç¾å†…å®¹
      const rand = Math.random();
      if (rand < 0.4) {
        const size = (40 + Math.random() * 20) * SCALE;
        const yPos = Math.random() < 0.3 ? groundY - 30 : groundY - 70 - Math.random() * 50;
        obstacles.push(new Obstacle('air', SPRITES.blueberry, yPos, size));
      } else {
        if (score > 10 && Math.random() < 0.3) {
          obstacles.push(new Obstacle('ground_large', SPRITES.sunflower, groundY, 120 * SCALE * 1.25));
        } else {
          const size = (60 + Math.random() * 20) * SCALE;
          obstacles.push(new Obstacle('ground', SPRITES.sunflower, groundY, size));
        }
      }

      // æ¬¡å›é–“éš”ã‚’å¼•ãç›´ã—
      nextSpawnInterval = minSpawnInterval + Math.random() * (maxSpawnInterval - minSpawnInterval);
      spawnTimer = 0;
    }

    function updateObstacles(d){
      for(let i=obstacles.length-1;i>=0;i--){
        obstacles[i].update(d);
        obstacles[i].draw();
        if(obstacles[i].x+obstacles[i].width<0)obstacles.splice(i,1);
      }
    }

    function checkCollision(){
      if (isDebug) return; // ãƒ‡ãƒãƒƒã‚°ã¯ç„¡æ•µ
      const p={x:player.x,y:player.y,width:player.width*0.6,height:player.height*0.7};
      for(const o of obstacles){
        const h=o.getHitbox();
        if(p.x<h.x+h.width&&p.x+p.width>h.x&&p.y<h.y+h.height&&p.y+p.height>h.y){
          gameOver(); return;
        }
      }
    }

    function updateScore(){
      for(const o of obstacles){
        if(!o.passed&&o.x+o.width<player.x){ score++; o.passed=true; }
      }
      scoreEl.textContent=score;
      const tSec=timeElapsed/1000;
      gameSpeed=baseGameSpeed+tSec*gameSpeedAcceleration;
    }

    function clearCanvas(){ ctx.clearRect(0,0,gameWidth,gameHeight); }
    function drawGround(){ ctx.fillStyle='#8B4513'; ctx.fillRect(0,groundY,gameWidth,gameHeight-groundY); }

    function buildXIntentUrl(score) {
      const text = `ã‚€ã‚‹ã ã£ã—ã‚…ï¼ã‚¹ã‚³ã‚¢ã¯ã€Œ${score}ã€ã§ã—ãŸğŸŒ»\nhttps://t4l-ovo-t4l.github.io/murudash/`;
      return `https://x.com/intent/tweet?text=${encodeURIComponent(text)}`;
    }

    function gameOver(){
      if(isGameOver)return;
      isGameOver=true; gameStarted=false;
      if(audioStarted){
        try{
          bgmAudio.pause(); bgmAudio.currentTime=0;
          endAudio.currentTime=0; endAudio.play();
        }catch(_){}
      }
      if(score>highScore){
        highScore=score;
        localStorage.setItem('muruHighScore',highScore);
        highScoreEl.textContent=`ãƒã‚¤ã‚¹ã‚³ã‚¢: ${highScore}`;
      }
      finalScoreEl.textContent=score;
      shareButton.href = buildXIntentUrl(score);
      gameOverScreen.classList.remove('hidden');
      gameOverScreen.classList.add('flex');
    }

    function restartGame(){
      startAudio();
      try{ if(bgmAudio){ bgmAudio.currentTime=0; bgmAudio.play(); } }catch(_){}
      score=0; scoreEl.textContent=score;
      timeElapsed=0; gameSpeed=baseGameSpeed;
      obstacles=[]; frame=0; spawnTimer=0;
      isGameOver=false; isPaused=false; gameStarted=true;
      player.y=groundY-player.height; player.dy=0; player.isGrounded=true; player.jumpsRemaining=2;
      gameOverScreen.classList.add('hidden'); gameOverScreen.classList.remove('flex');
      pauseOverlay.classList.add('hidden');

      // âœ… ãƒ•ã‚§ãƒ¼ã‚ºã‚‚ç¢ºå®Ÿã«ãƒªã‚»ãƒƒãƒˆ
      enterPhase(0);

      // ãƒ‡ãƒãƒƒã‚°åˆæœŸåŒ–
      isDebug = false; resetDebugTapCounter(); const dbg=document.getElementById('debugBadge'); if(dbg) dbg.remove();

      // ã‚¹ãƒãƒ¼ãƒ³åˆæœŸåŒ–
      spawnTimer = 0;
      nextSpawnInterval = minSpawnIntervalBase + Math.random() * (maxSpawnIntervalBase - minSpawnIntervalBase);

      lastTime=performance.now(); requestAnimationFrame(gameLoop);
    }

    function togglePause(){
      if(isGameOver||!gameStarted)return;
      isPaused=!isPaused;
      if(isPaused){
        try{ if(bgmAudio)bgmAudio.pause(); }catch(_){}
        pauseOverlay.classList.remove('hidden'); pauseOverlay.classList.add('flex');
      }else{
        try{ if(bgmAudio)bgmAudio.play(); }catch(_){}
        pauseOverlay.classList.add('hidden'); pauseOverlay.classList.remove('flex');
        lastTime=performance.now(); requestAnimationFrame(gameLoop);
        resetDebugTapCounter();
      }
    }

    function enableDebugMode(){
      if(isDebug) return;
      isDebug = true;
      const debugBadge = document.createElement('span');
      debugBadge.id = 'debugBadge';
      debugBadge.textContent = 'DEBUG';
      debugBadge.className = 'px-2 py-1 bg-pink-600 text-white text-xs font-bold rounded shadow-sm';
      highScoreEl.parentElement.appendChild(debugBadge);
    }
    function resetDebugTapCounter(){ debugTapCount = 0; }

    function gameLoop(timestamp){
      if(isGameOver||isPaused||!gameStarted)return;
      const deltaTime=timestamp-lastTime; lastTime=timestamp;
      const deltaFactor=deltaTime/(1000/60);
      timeElapsed+=deltaTime;

      // âœ… ãƒ•ã‚§ãƒ¼ã‚ºæ›´æ–°ï¼ˆå¤•æ–¹ã§æ­¢ã¾ã‚‰ãªã„ï¼‰
      updatePhase(deltaTime);

      clearCanvas(); drawSky(deltaFactor); drawClouds(deltaFactor);
      drawGround(); updatePlayer(deltaFactor); drawPlayer();
      spawnObstacle(deltaFactor); updateObstacles(deltaFactor); checkCollision(); updateScore();
      frame++; requestAnimationFrame(gameLoop);
    }

    // å…¥åŠ›
    window.addEventListener('keydown', e => {
      if (e.repeat) return;

      // ãƒãƒ¼ã‚ºä¸­ï¼šã‚¸ãƒ£ãƒ³ãƒ—ç³»5å›ã§ãƒ‡ãƒãƒƒã‚°ON
      if (isPaused && (e.code === 'Space' || e.code === 'ArrowUp')) {
        debugTapCount++;
        if (debugTapCount >= 5) { enableDebugMode(); resetDebugTapCounter(); }
        return;
      }
      if (!gameStarted) return;

      if (e.code === 'Space' || e.code === 'ArrowUp') playerJump();
      if (e.code === 'KeyP') togglePause();
    });
    window.addEventListener('keyup', e => {
      if (e.code === 'Space' || e.code === 'ArrowUp') stopJump();
    });

    jumpButton.addEventListener('pointerdown', e => {
      e.preventDefault();
      if (isPaused) {
        debugTapCount++;
        if (debugTapCount >= 5) { enableDebugMode(); resetDebugTapCounter(); }
        return;
      }
      playerJump();
    });
    jumpButton.addEventListener('pointerup', e => { e.preventDefault(); stopJump(); });

    pauseButton.addEventListener('click', e => { e.preventDefault(); togglePause(); if (!isPaused) resetDebugTapCounter(); });
    pauseButton.addEventListener('touchstart', e => { e.preventDefault(); togglePause(); if (!isPaused) resetDebugTapCounter(); });

    restartButton.addEventListener('click', e => {
      e.preventDefault(); restartGame();
      isDebug = false; resetDebugTapCounter(); const dbg=document.getElementById('debugBadge'); if(dbg) dbg.remove();
    });
    restartButton.addEventListener('touchstart', e => {
      e.preventDefault(); restartGame();
      isDebug = false; resetDebugTapCounter(); const dbg=document.getElementById('debugBadge'); if(dbg) dbg.remove();
    });

    function handleGameStart(e){
      e.preventDefault();
      if (gameStarted) return;
      gameStarted = true;
      startAudio();
      startScreen.classList.add('hidden');
      lastTime = performance.now();
      requestAnimationFrame(gameLoop);
      nextSpawnInterval = minSpawnIntervalBase + Math.random() * (maxSpawnIntervalBase - minSpawnIntervalBase);
      spawnTimer = 0;
      resetDebugTapCounter();
    }
    startButton.addEventListener('click', handleGameStart);
    startButton.addEventListener('touchstart', handleGameStart);
  </script>
</body>
</html>