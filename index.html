<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>ã‚€ã‚‹ã ã£ã—ã‚…ï¼</title>
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
    body {
      font-family: 'Inter', sans-serif;
      touch-action: manipulation;
      overflow: hidden;
      overscroll-behavior: none;
    }
    canvas {
      background-color: #f7fafc;
      display: block;
      background-image: linear-gradient(to bottom, #a0d2eb, #f7fafc 80%);
    }
    .control-button { transition: background-color 0.1s ease, transform 0.1s ease; }
    .control-button:active { transform: scale(0.95); background-color: #2c5282; }
    .pause-button { transition: background-color 0.1s ease, transform 0.1s ease; }
    .pause-button:active { transform: scale(0.95); }
  </style>
</head>
<body class="bg-gray-200 flex flex-col items-center justify-center h-screen">

  <!-- ãƒ˜ãƒƒãƒ€ãƒ¼ -->
  <div class="w-full max-w-lg p-4 flex justify-between items-center bg-white rounded-t-lg shadow-md">
    <div>
      <h1 class="text-xl font-bold text-gray-800">ã‚€ã‚‹ã ã£ã—ã‚…ï¼</h1>
      <p class="text-sm text-gray-600">2æ®µã‚¸ãƒ£ãƒ³ãƒ—ã‚‚ã§ãã‚‹ã‚ˆ</p>
    </div>
    <div class="flex items-center gap-4">
      <div class="text-right">
        <span class="text-2xl font-bold text-blue-600">ã‚¹ã‚³ã‚¢: <span id="score">0</span></span>
        <span id="highScore" class="text-xs text-gray-500 block">ãƒã‚¤ã‚¹ã‚³ã‚¢: 0</span>
      </div>
      <button id="pauseButton" class="pause-button px-4 py-2 bg-yellow-500 text-white font-bold rounded-lg shadow-md text-sm">
        ã¡ã‚‡ã£ã¨ä¼‘æ†©
      </button>
    </div>
  </div>

  <!-- ã‚­ãƒ£ãƒ³ãƒã‚¹ï¼†ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ -->
  <div class="relative w-full max-w-lg">
    <canvas id="gameCanvas" class="rounded-b-lg shadow-md"></canvas>

    <!-- ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ -->
    <div id="startScreen" class="absolute inset-0 bg-black bg-opacity-70 flex-col justify-center items-center rounded-b-lg text-white p-8 text-center flex">
      <h2 class="text-5xl font-bold mb-6">ã‚€ã‚‹ã ã£ã—ã‚…ï¼</h2>
      <p class="text-lg mb-4">ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ã‚¸ãƒ£ãƒ³ãƒ—ï¼<br>ç©ºä¸­ã§ã‚‚ã†ä¸€å›ã§2æ®µã‚¸ãƒ£ãƒ³ãƒ—ï¼</p>
      <p class="text-lg mb-8">éšœå®³ç‰©ã‚’ã‚ˆã‘ã¾ãã‚ã†ï¼</p>
      <button id="startButton" class="px-8 py-4 bg-green-600 text-white font-bold rounded-lg shadow-lg text-2xl hover:bg-green-700 transition-colors">
        ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆ
      </button>
    </div>

    <!-- ãƒãƒ¼ã‚º -->
    <div id="pauseOverlay" class="absolute inset-0 bg-black bg-opacity-50 flex-col justify-center items-center rounded-b-lg text-white p-8 text-center hidden">
      <h2 class="text-4xl font-bold mb-4">ä¸€æ™‚åœæ­¢ä¸­</h2>
      <p class="text-xl">(ã€Œã¡ã‚‡ã£ã¨ä¼‘æ†©ã€ãƒœã‚¿ãƒ³ã§å†é–‹)</p>
    </div>

    <!-- ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ -->
    <div id="gameOverScreen" class="absolute inset-0 bg-black bg-opacity-50 flex-col justify-center items-center rounded-lg text-white p-8 text-center hidden">
      <h2 class="text-4xl font-bold mb-4">ãŒã‚ãŠã¹ã‚‰</h2>
      <p class="text-xl mb-6">ã‚¹ã‚³ã‚¢: <span id="finalScore">0</span></p>
      <button id="restartButton" class="px-8 py-4 bg-blue-600 text-white font-bold rounded-lg shadow-lg text-xl hover:bg-blue-700 transition-colors">
        ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ
      </button>
    </div>
  </div>

  <!-- ã‚¹ãƒãƒ›ç”¨ã‚¸ãƒ£ãƒ³ãƒ— -->
  <div class="w-full max-w-lg flex justify-center p-4 fixed bottom-0 left-1/2 -translate-x-1/2">
    <button id="jumpButton" class="control-button w-3/4 py-8 bg-blue-600 text-white font-bold rounded-lg shadow-lg text-2xl">
      ã‚¸ãƒ£ãƒ³ãƒ—
    </button>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const highScoreEl = document.getElementById('highScore');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const finalScoreEl = document.getElementById('finalScore');
    const restartButton = document.getElementById('restartButton');
    const jumpButton = document.getElementById('jumpButton');
    const pauseButton = document.getElementById('pauseButton');
    const pauseOverlay = document.getElementById('pauseOverlay');
    const startScreen = document.getElementById('startScreen');
    const startButton = document.getElementById('startButton');

    // --- Audio (mp3) ---
    let audioStarted = false;
    let bgmAudio, endAudio;

    async function startAudio() {
      if (audioStarted) return;
      try {
        bgmAudio = new Audio('./assets/BGM.mp3');
        bgmAudio.loop = true;
        bgmAudio.volume = 0.5; // ğŸ”Š BGMã¯åŠåˆ†
        await bgmAudio.play(); // åˆå›ã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œç›´å¾Œã«å‘¼ã°ã‚Œã‚‹

        endAudio = new Audio('./assets/END.mp3');
        endAudio.volume = 0.8;

        audioStarted = true;
        console.log('Audio started');
      } catch (e) {
        console.error('Audio init failed:', e);
      }
    }

    // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚º
    const parentWidth = canvas.parentElement.clientWidth;
    const gameWidth = Math.min(parentWidth, 768);
    const gameHeight = 300;
    canvas.width = gameWidth;
    canvas.height = gameHeight;

    // å¤‰æ•°
    let score = 0;
    let highScore = localStorage.getItem('muruHighScore') || 0;
    let gameSpeed = 5;
    let baseGameSpeed = 5;
    let gameSpeedAcceleration = 0.05; // 1ç§’ã‚ãŸã‚ŠåŠ é€Ÿ
    let timeElapsed = 0;

    let obstacles = [];
    let backgroundObjects = [];
    let groundObjects = [];
    let frame = 0;
    let spawnTimer = 0;
    let minSpawnInterval = 90;
    let maxSpawnInterval = 180;
    const minSpawnIntervalBase = 90;
    const maxSpawnIntervalBase = 180;
    const spawnIntervalReductionPerSec = 4;

    let isGameOver = false;
    let isPaused = false;
    let gameStarted = false;

    // ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ 
    let lastTime = 0;
    const baseDeltaTime = 1000 / 60;

    highScoreEl.textContent = `ãƒã‚¤ã‚¹ã‚³ã‚¢: ${highScore}`;

    // åœ°é¢
    const groundY = gameHeight - 50;

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
    const player = {
      x: 50,
      y: groundY - 50,
      width: 50,
      height: 50,
      originalHeight: 50,
      dy: 0,
      gravity: 0.8,
      jumpForce: 15,
      isGrounded: true,
      jumpsRemaining: 2,
      isJumping: false,
      image: new Image(),
      imageLoaded: false
    };

    player.image.src = './assets/Muru.png';
    player.image.onload = () => {
      player.imageLoaded = true;
      player.width = (player.image.width / player.image.height) * player.height;
    };
    player.image.onerror = () => {
      console.error('ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
      player.imageLoaded = false;
    };

    function drawPlayer() {
      const drawHeight = player.height;
      const drawY = player.y;
      if (player.imageLoaded) {
        ctx.drawImage(player.image, player.x, drawY, player.width, drawHeight);
      } else {
        ctx.fillStyle = 'green';
        ctx.fillRect(player.x, drawY, player.width, drawHeight);
      }
    }

    function updatePlayer(deltaFactor) {
      if (!player.isGrounded) {
        player.dy += player.gravity * deltaFactor;
        player.y += player.dy * deltaFactor;
      }
      if (player.y + player.height >= groundY) {
        player.y = groundY - player.height;
        player.dy = 0;
        player.isGrounded = true;
        player.jumpsRemaining = 2;
      }
      player.height = player.originalHeight;
    }

    function playerJump() {
      startAudio(); // ãƒ¢ãƒã‚¤ãƒ«ã®åˆå›ã‚¸ã‚§ã‚¹ãƒãƒ£ã§èµ°ã‚‰ã›ã‚‹
      if (isGameOver || isPaused || !gameStarted) return;

      if (player.jumpsRemaining > 0) {
        player.dy = -player.jumpForce;
        player.isGrounded = false;
        player.isJumping = true;
        player.jumpsRemaining--;
      }
    }

    function stopJump() {
      if (player.isJumping && player.dy < 0) {
        player.dy = Math.max(player.dy, -5);
      }
      player.isJumping = false;
    }

    // èƒŒæ™¯
    class BackgroundObject {
      constructor(emoji, y, fontSize, speedMultiplier) {
        this.x = gameWidth;
        this.y = y;
        this.emoji = emoji;
        this.fontSize = fontSize;
        this.speedMultiplier = speedMultiplier;
      }
      draw() {
        ctx.font = `${this.fontSize}px Arial`;
        ctx.globalAlpha = 0.5;
        ctx.fillText(this.emoji, this.x, this.y);
        ctx.globalAlpha = 1.0;
      }
      update(deltaFactor) { this.x -= gameSpeed * this.speedMultiplier * deltaFactor; }
    }
    function spawnBackgroundObject() {
      if (Math.random() < 0.01) {
        const y = Math.random() * (gameHeight / 2);
        const fontSize = 20 + Math.random() * 30;
        const speedMultiplier = 0.2 + Math.random() * 0.3;
        backgroundObjects.push(new BackgroundObject('â˜ï¸', y, fontSize, speedMultiplier));
      }
    }
    function updateBackgroundObjects(deltaFactor) {
      for (let i = backgroundObjects.length - 1; i >= 0; i--) {
        backgroundObjects[i].update(deltaFactor);
        backgroundObjects[i].draw();
        if (backgroundObjects[i].x < -50) backgroundObjects.splice(i, 1);
      }
    }

    // åœ°é¢ã®ç²’
    class GroundObject {
      constructor(text, y, fontSize, color) {
        this.x = gameWidth;
        this.y = y;
        this.text = text;
        this.fontSize = fontSize;
        this.color = color;
      }
      draw() {
        ctx.font = `${this.fontSize}px Arial`;
        ctx.fillStyle = this.color;
        ctx.fillText(this.text, this.x, this.y);
      }
      update(deltaFactor) { this.x -= gameSpeed * deltaFactor; }
    }
    function spawnGroundObject() {
      if (Math.random() < 0.05) {
        const y = groundY + 10 + Math.random() * 30;
        const fontSize = 5 + Math.random() * 5;
        const color = Math.random() < 0.5 ? '#A0522D' : '#696969';
        const text = Math.random() < 0.5 ? 'â€¢' : 'Â·';
        groundObjects.push(new GroundObject(text, y, fontSize, color));
      }
    }
    function updateGroundObjects(deltaFactor) {
      for (let i = groundObjects.length - 1; i >= 0; i--) {
        groundObjects[i].update(deltaFactor);
        groundObjects[i].draw();
        if (groundObjects[i].x < -10) groundObjects.splice(i, 1);
      }
    }

    // éšœå®³ç‰©
    class Obstacle {
      constructor(type, emoji, y, fontSize) {
        this.x = gameWidth;
        this.y = y;
        this.type = type; // 'ground', 'air', 'ground_large'
        this.emoji = emoji;
        this.fontSize = fontSize;
        this.width = fontSize * 0.8;
        this.height = fontSize * 0.8;
        this.passed = false;
      }
      draw() {
        ctx.font = `${this.fontSize}px Arial`;
        ctx.fillText(this.emoji, this.x, this.y);
      }
      update(deltaFactor) { this.x -= gameSpeed * deltaFactor; }
      getHitbox() {
        return { x: this.x, y: this.y - this.height, width: this.width, height: this.height };
      }
    }

    function spawnObstacle(deltaFactor) {
      spawnTimer += deltaFactor;
      if (spawnTimer < minSpawnInterval) return;

      spawnTimer = 0;
      const next = Math.floor(Math.random() * (maxSpawnInterval - minSpawnInterval) + minSpawnInterval);
      // æ¬¡ã®é–“éš”ã¯ minSpawnInterval ã«ã‚ˆã£ã¦æ›´æ–°ã•ã‚Œã‚‹ã®ã§ä¿å­˜
      // (å¯èª­æ€§ã®ãŸã‚å¤‰æ•°åã¯ä½¿ã‚ãšã«ãã®ã¾ã¾é€²è¡Œ)

      const rand = Math.random();
      if (rand < 0.4) {
        const fontSize = 30 + Math.random() * 10;
        let yPos;
        if (Math.random() < 0.3) {
          yPos = groundY - 30; // ä½ç©º
        } else {
          yPos = groundY - 70 - Math.random() * 50;
        }
        obstacles.push(new Obstacle('air', 'ğŸ«', yPos, fontSize));
      } else {
        if (score > 10 && Math.random() < 0.3) {
          const fontSize = 110;
          obstacles.push(new Obstacle('ground_large', 'ğŸŒ»', groundY, fontSize));
        } else {
          const fontSize = 40 + Math.random() * 10;
          obstacles.push(new Obstacle('ground', 'ğŸŒ»', groundY, fontSize));
        }
      }
      // æ¬¡ã®ã‚¹ãƒãƒ¼ãƒ³ã¾ã§ã®ã‚«ã‚¦ãƒ³ãƒˆã‚’æ›´æ–°
      minSpawnInterval = Math.max(minSpawnIntervalBase - (timeElapsed / 1000) * spawnIntervalReductionPerSec, 40);
      maxSpawnInterval = Math.max(maxSpawnIntervalBase - (timeElapsed / 1000) * spawnIntervalReductionPerSec, 80);
    }

    function updateObstacles(deltaFactor) {
      for (let i = obstacles.length - 1; i >= 0; i--) {
        obstacles[i].update(deltaFactor);
        obstacles[i].draw();
        if (obstacles[i].x + obstacles[i].width < 0) obstacles.splice(i, 1);
      }
    }

    function checkCollision() {
      const playerHitbox = {
        x: player.x,
        y: player.y,
        width: player.width * 0.8,
        height: player.height * 0.8
      };
      for (const obstacle of obstacles) {
        const obsHit = obstacle.getHitbox();
        if (
          playerHitbox.x < obsHit.x + obsHit.width &&
          playerHitbox.x + playerHitbox.width > obsHit.x &&
          playerHitbox.y < obsHit.y + obsHit.height &&
          playerHitbox.y + playerHitbox.height > obsHit.y
        ) {
          gameOver();
          return;
        }
      }
    }

    function updateScore() {
      for (const obstacle of obstacles) {
        if (!obstacle.passed && obstacle.x + obstacle.width < player.x) {
          score++;
          obstacle.passed = true;
        }
      }
      scoreEl.textContent = score;

      const timeInSeconds = timeElapsed / 1000;
      gameSpeed = baseGameSpeed + timeInSeconds * gameSpeedAcceleration;
      minSpawnInterval = Math.max(minSpawnIntervalBase - timeInSeconds * spawnIntervalReductionPerSec, 40);
      maxSpawnInterval = Math.max(maxSpawnIntervalBase - timeInSeconds * spawnIntervalReductionPerSec, 80);
    }

    function drawGround() {
      ctx.fillStyle = '#8B4513';
      ctx.fillRect(0, groundY, gameWidth, gameHeight - groundY);
    }

    function clearCanvas() {
      ctx.clearRect(0, 0, gameWidth, gameHeight);
    }

    function gameOver() {
      if (isGameOver) return;
      isGameOver = true;
      gameStarted = false;

      // éŸ³
      if (audioStarted) {
        try {
          bgmAudio.pause();
          bgmAudio.currentTime = 0;
          endAudio.currentTime = 0;
          endAudio.play();
        } catch (_) {}
      }

      if (score > highScore) {
        highScore = score;
        localStorage.setItem('muruHighScore', highScore);
        highScoreEl.textContent = `ãƒã‚¤ã‚¹ã‚³ã‚¢: ${highScore}`;
      }
      finalScoreEl.textContent = score;
      gameOverScreen.classList.remove('hidden');
      gameOverScreen.classList.add('flex');
    }

    function restartGame() {
      startAudio();
      try {
        if (bgmAudio) {
          bgmAudio.currentTime = 0;
          bgmAudio.play();
        }
      } catch (_) {}

      score = 0;
      scoreEl.textContent = score;
      timeElapsed = 0;
      gameSpeed = baseGameSpeed;
      minSpawnInterval = minSpawnIntervalBase;
      maxSpawnInterval = maxSpawnIntervalBase;
      obstacles = [];
      backgroundObjects = [];
      groundObjects = [];
      frame = 0;
      spawnTimer = 0;
      isGameOver = false;
      isPaused = false;
      gameStarted = true;
      player.y = groundY - player.height;
      player.dy = 0;
      player.isGrounded = true;
      player.jumpsRemaining = 2;

      gameOverScreen.classList.add('hidden');
      gameOverScreen.classList.remove('flex');
      pauseOverlay.classList.add('hidden');

      lastTime = performance.now();
      requestAnimationFrame(gameLoop);
    }

    function togglePause() {
      if (isGameOver || !gameStarted) return;
      isPaused = !isPaused;

      if (isPaused) {
        try { if (bgmAudio) bgmAudio.pause(); } catch (_) {}
        pauseOverlay.classList.remove('hidden');
        pauseOverlay.classList.add('flex');
      } else {
        try { if (bgmAudio) bgmAudio.play(); } catch (_) {}
        pauseOverlay.classList.add('hidden');
        pauseOverlay.classList.remove('flex');
        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
      }
    }

    // ãƒ«ãƒ¼ãƒ—
    function gameLoop(timestamp) {
      if (isGameOver || isPaused || !gameStarted) return;

      const deltaTime = timestamp - lastTime;
      lastTime = timestamp;
      const deltaFactor = deltaTime / baseDeltaTime;

      timeElapsed += deltaTime;

      if (deltaFactor > 4) {
        requestAnimationFrame(gameLoop);
        return;
      }

      clearCanvas();
      spawnBackgroundObject();
      updateBackgroundObjects(deltaFactor);

      drawGround();

      spawnGroundObject();
      updateGroundObjects(deltaFactor);

      updatePlayer(deltaFactor);
      drawPlayer();

      spawnObstacle(deltaFactor);
      updateObstacles(deltaFactor);

      checkCollision();
      updateScore();

      frame++;
      requestAnimationFrame(gameLoop);
    }

    // å…¥åŠ›
    window.addEventListener('keydown', (e) => {
      if (e.repeat) return;
      if (!gameStarted) return;
      if (e.code === 'Space' || e.code === 'ArrowUp') playerJump();
      if (e.code === 'KeyP') togglePause();
    });
    window.addEventListener('keyup', (e) => {
      if (e.code === 'Space' || e.code === 'ArrowUp') stopJump();
    });

    if (jumpButton) {
      jumpButton.addEventListener('pointerdown', (e) => { e.preventDefault(); playerJump(); });
      jumpButton.addEventListener('pointerup',   (e) => { e.preventDefault(); stopJump();  });
    }

    if (pauseButton) {
      pauseButton.addEventListener('click', (e) => { e.preventDefault(); togglePause(); });
      pauseButton.addEventListener('touchstart', (e) => { e.preventDefault(); togglePause(); });
    }

    function handleGameStart(e) {
      e.preventDefault();
      if (gameStarted) return;
      console.log('Game Start!');
      gameStarted = true;
      startAudio();
      startScreen.classList.add('hidden');
      lastTime = performance.now();
      requestAnimationFrame(gameLoop);
    }

    startButton.addEventListener('click', handleGameStart);
    startButton.addEventListener('touchstart', handleGameStart);
  </script>
</body>
</html>
