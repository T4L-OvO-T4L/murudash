<!DOCTYPE html>
<html lang="ja">
<head>
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://cdn.tailwindcss.com 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; img-src 'self' data:; media-src 'self';">
<meta name="referrer" content="strict-origin-when-cross-origin">
<link rel="preload" as="image" href="./assets/blueberry.svg">
<link rel="preload" as="image" href="./assets/sunflower.svg">
<link rel="preload" as="audio" href="./assets/BGM.mp3">
<link rel="preload" as="audio" href="./assets/END.mp3">
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>ã‚€ã‚‹ã ã£ã—ã‚…ï¼</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
  body { font-family:'Inter',sans-serif; touch-action:manipulation; overflow:hidden; overscroll-behavior:none; background:#1a202c; }
  canvas { display:block; }
  .control-button { transition: background-color .1s, transform .1s; }
  .control-button:active { transform: scale(.95); background:#2c5282; }
  .pause-button { transition: background-color .1s, transform .1s; }
  .pause-button:active { transform: scale(.95); }
</style>
</head>
<body class="bg-gray-800 flex flex-col items-center justify-start min-h-screen pt-3 sm:pt-4 pb-28">

<!-- æ³¨æ„æ›¸ãï¼ˆiOS Safariè¡Œã¯å‰Šé™¤æ¸ˆã¿ï¼‰ -->
<div class="w-full text-center bg-gray-900 text-gray-300 text-[11px] py-1 shadow-md">
  â€»æœ¬ä½œå“ã¯ <a href="https://kuronekotsuki.booth.pm/items/4672957" target="_blank" rel="noopener noreferrer" class="underline hover:text-white transition">ï½¢ãƒ ãƒ«ãƒ«ï½£</a> ã‚’ãƒ¢ãƒãƒ¼ãƒ•ã«ã—ãŸéå…¬å¼ãƒ•ã‚¡ãƒ³ä½œå“ã§ã™ã€‚<br class="sm:hidden">
  æ¨©åˆ©è€…æ§˜ã¨ã¯ä¸€åˆ‡é–¢ä¿‚ã‚ã‚Šã¾ã›ã‚“ã€‚<br>
  â€»éŸ³ãŒå‡ºã¾ã™ã€‚ã”æ³¨æ„ãã ã•ã„ã€‚
</div>

<!-- ãƒ˜ãƒƒãƒ€ãƒ¼ -->
<div class="w-full max-w-lg p-3 bg-white rounded-t-lg shadow-md">
  <div class="flex items-center justify-between gap-3">
    <div class="text-left">
      <span class="text-xl sm:text-2xl font-bold text-blue-600">
        ã‚¹ã‚³ã‚¢: <span id="score" class="inline-block min-w-[60px] text-right font-mono">0</span>
      </span>
    </div>
    <div class="flex items-center gap-3 shrink-0">
      <span id="highScore" class="text-xs text-gray-500 block">ãƒã‚¤ã‚¹ã‚³ã‚¢: 0</span>
      <button id="pauseButton" class="pause-button px-3 py-2 sm:px-4 sm:py-2 bg-yellow-500 text-white font-bold rounded-lg shadow-md text-sm">
        ã¡ã‚‡ã£ã¨ä¼‘æ†©
      </button>
    </div>
  </div>
</div>

<!-- ã‚­ãƒ£ãƒ³ãƒã‚¹ï¼†ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ -->
<div class="relative w-full max-w-lg mt-2 mb-24">
  <canvas id="gameCanvas" class="rounded-b-lg shadow-md"></canvas>

  <!-- ã‚¹ã‚¿ãƒ¼ãƒˆ -->
  <div id="startScreen" class="absolute inset-0 bg-black bg-opacity-70 flex-col justify-center items-center rounded-b-lg text-white p-8 text-center flex">
    <h2 class="text-5xl font-bold mb-6">ã‚€ã‚‹ã ã£ã—ã‚…ï¼</h2>
    <p class="text-lg mb-4">ãƒœã‚¿ãƒ³ã§ã‚¸ãƒ£ãƒ³ãƒ—ï¼ç©ºä¸­ã§ã‚‚ã†ä¸€å›ã§2æ®µã‚¸ãƒ£ãƒ³ãƒ—ï¼</p>
    <p class="text-lg mb-8">éšœå®³ç‰©ã‚’ã‚ˆã‘ã¾ãã‚ã†ï¼</p>
    <button id="startButton" class="px-8 py-4 bg-green-600 text-white font-bold rounded-lg shadow-lg text-2xl hover:bg-green-700 transition-colors">
      ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆ
    </button>
  </div>

  <!-- ãƒãƒ¼ã‚º -->
  <div id="pauseOverlay" class="absolute inset-0 bg-black bg-opacity-50 flex-col justify-center items-center rounded-b-lg text-white p-8 text-center hidden">
    <h2 class="text-4xl font-bold mb-4">ä¸€æ™‚åœæ­¢ä¸­</h2>
    <p class="text-xl">(ã€Œã¡ã‚‡ã£ã¨ä¼‘æ†©ã€ãƒœã‚¿ãƒ³ã§å†é–‹)</p>
  </div>

  <!-- ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ -->
  <div id="gameOverScreen" class="absolute inset-0 bg-black bg-opacity-50 flex-col justify-center items-center rounded-lg text-white p-8 text-center hidden">
    <h2 class="text-4xl font-bold mb-4">ãŒã‚ãŠã¹ã‚‰</h2>
    <p class="text-xl mb-6">ã‚¹ã‚³ã‚¢: <span id="finalScore">0</span></p>
    <div class="flex flex-wrap justify-center gap-3">
      <button id="restartButton" class="px-8 py-4 bg-blue-600 text-white font-bold rounded-lg shadow-lg text-xl hover:bg-blue-700 transition-colors">
        ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ
      </button>
      <a id="shareButton" href="#" target="_blank" rel="noopener noreferrer" class="px-8 py-4 bg-black text-white font-bold rounded-lg shadow-lg text-xl hover:bg-gray-900 transition-colors">
        Xã§ã‚¹ã‚³ã‚¢ã‚’ã‚·ã‚§ã‚¢
      </a>
    </div>
  </div>
</div>

<!-- ã‚¸ãƒ£ãƒ³ãƒ—ãƒœã‚¿ãƒ³ -->
<div class="w-full max-w-lg flex justify-center p-4 fixed bottom-0 left-1/2 -translate-x-1/2">
  <button id="jumpButton" class="control-button w-full py-12 bg-blue-600 text-white font-bold rounded-lg shadow-lg text-2xl">ã‚¸ãƒ£ãƒ³ãƒ—</button>
</div>

<script>
/* ===== åŸºæœ¬ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— ===== */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const highScoreEl = document.getElementById('highScore');
const gameOverScreen = document.getElementById('gameOverScreen');
const finalScoreEl = document.getElementById('finalScore');
const restartButton = document.getElementById('restartButton');
const shareButton = document.getElementById('shareButton');
const jumpButton = document.getElementById('jumpButton');
const pauseButton = document.getElementById('pauseButton');
const pauseOverlay = document.getElementById('pauseOverlay');
const startScreen = document.getElementById('startScreen');
const startButton = document.getElementById('startButton');

function loadImg(src){ const img=new Image(); img.src=src; return img; }
const SPRITES={ blueberry:loadImg('./assets/blueberry.svg'), sunflower:loadImg('./assets/sunflower.svg') };

/* ===== ã‚ªãƒ¼ãƒ‡ã‚£ã‚ª ===== */
let audioStarted=false, bgmAudio, endAudio;
async function startAudio(){
  if(audioStarted) return;
  try{
    bgmAudio = new Audio('./assets/BGM.mp3');
    bgmAudio.volume = 0.5;
    bgmAudio.loop = true; // ãƒ«ãƒ¼ãƒ—ã¯ä½¿ã†ã‘ã©ã€ãƒ«ãƒ¼ãƒ—æ¤œçŸ¥ã¯æ™‚é–“é€†è¡Œã§æ‹¾ã†
    await bgmAudio.play();
    endAudio = new Audio('./assets/END.mp3'); endAudio.volume=0.5;
    audioStarted = true;
  }catch(e){ console.error(e); }
}

/* ===== ç”»é¢ã‚µã‚¤ã‚º ===== */
const parentWidth = canvas.parentElement.clientWidth;
const gameWidth = Math.min(parentWidth, 768);
const gameHeight = 300;
canvas.width = gameWidth; canvas.height = gameHeight;

/* ===== ç©ºã®ãƒ†ãƒ¼ãƒï¼ˆæ›²ã‚¿ã‚¤ãƒŸãƒ³ã‚°é€£å‹•ï¼‰ ===== */
const THEMES={
  morning:{ top:[160,210,235], bottom:[247,250,252] },
  evening:{ top:[246,173, 85], bottom:[253,230,138] },
  night:  { top:[45,55,90],    bottom:[20,25,50] }
};
let skyCurrent = { top:[...THEMES.morning.top], bottom:[...THEMES.morning.bottom] };
let skyTarget  = { top:[...THEMES.morning.top], bottom:[...THEMES.morning.bottom] };
const skyLerpSpeed = 0.03;

let phaseName = 'morning'; // 'morning' | 'evening' | 'night'
function setBackgroundTheme(themeKey){
  const t = THEMES[themeKey] || THEMES.morning;
  skyTarget = { top:[...t.top], bottom:[...t.bottom] };
  phaseName = themeKey; // é›²ã®å¤œåˆ¤å®šã«ã‚‚ä½¿ã†
}
function drawSky(deltaFactor){
  const t = Math.min(1, skyLerpSpeed * deltaFactor);
  for(let i=0;i<3;i++){
    skyCurrent.top[i]    += (skyTarget.top[i]    - skyCurrent.top[i])    * t;
    skyCurrent.bottom[i] += (skyTarget.bottom[i] - skyCurrent.bottom[i]) * t;
  }
  const g = ctx.createLinearGradient(0,0,0,gameHeight);
  const top = `rgb(${skyCurrent.top.map(x=>x|0).join(',')})`;
  const bottom = `rgb(${skyCurrent.bottom.map(x=>x|0).join(',')})`;
  g.addColorStop(0, top); g.addColorStop(0.8, bottom);
  ctx.fillStyle = g; ctx.fillRect(0,0,gameWidth,gameHeight);
}

/* ===== æ›²ã‚¿ã‚¤ãƒŸãƒ³ã‚°é€£å‹• ===== */
const EVENING_MARK_S = 95;   // 1:35ã§å¤•æ–¹
const EPS = 0.25;

let lastAudioTime = 0;
let loopCount = 0;                 // 1å›ãƒ«ãƒ¼ãƒ—ã§+1
let eveningTriggeredThisCycle = false;

function resetAudioSyncState(){
  lastAudioTime = 0;
  loopCount = 0;
  eveningTriggeredThisCycle = false;
  setBackgroundTheme('morning'); // åˆæœŸã¯æœ
}

function updateSkyByMusic(){
  if(!bgmAudio) return;
  const t = bgmAudio.currentTime || 0;

  // å„å‘¨ä¸€å›ã ã‘å¤•æ–¹åŒ–
  if(!eveningTriggeredThisCycle && t >= EVENING_MARK_S - EPS){
    setBackgroundTheme('evening');
    eveningTriggeredThisCycle = true;
  }

  // ãƒ«ãƒ¼ãƒ—æ¤œçŸ¥ï¼ˆcurrentTime ãŒé€†è¡Œã—ãŸã‚‰ï¼‰
  if(t + EPS < lastAudioTime){
    loopCount++;
    eveningTriggeredThisCycle = false; // æ¬¡å‘¨ã®å¤•æ–¹ãƒˆãƒªã‚¬è§£æ”¾
    const toNight = (loopCount % 2 === 1);
    setBackgroundTheme(toNight ? 'night' : 'morning'); // 1å‘¨ç›®â†’å¤œã€2å‘¨ç›®â†’æœã€äº¤äº’
  }

  lastAudioTime = t;
}

/* ===== é›² ===== */
let clouds = Array.from({length:5},()=>({
  x: Math.random()*gameWidth,
  y: 40 + Math.random()*90,
  speed: 0.12 + Math.random()*0.18,
  size: 60 + Math.random()*60
}));
function drawClouds(deltaFactor){
  const isNight = (phaseName === 'night');
  const alpha = isNight ? 0.35 : 0.45;
  ctx.fillStyle = `rgba(255,255,255,${alpha})`;
  for(const c of clouds){
    c.x -= c.speed * deltaFactor;
    if(c.x < -200) c.x = gameWidth + 100;
    ctx.beginPath(); ctx.ellipse(c.x, c.y, c.size, c.size*0.6, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(c.x + c.size*0.6, c.y + 10, c.size*0.9, c.size*0.5, 0, 0, Math.PI*2); ctx.fill();
  }
}

/* ===== ã‚²ãƒ¼ãƒ æœ¬ä½“ ===== */
let score=0, highScore=localStorage.getItem('muruHighScore')||0; highScoreEl.textContent=`ãƒã‚¤ã‚¹ã‚³ã‚¢: ${highScore}`;

/* é€Ÿåº¦ï¼šãƒ™ãƒ¼ã‚¹ï¼‹åŠ é€Ÿã€ãŸã ã—ä¸Šé™ã‚’è¨­ã‘ã¦æ‰“ã¡æ­¢ã‚ */
let gameSpeed=5, baseGameSpeed=5, gameSpeedAcceleration=0.05;
const GAME_SPEED_MAX = 12; // â˜… ä¸Šé™ã‚¹ãƒ”ãƒ¼ãƒ‰ï¼ˆ11ã€œ14ãã‚‰ã„ãŒä½“æ„Ÿã¡ã‚‡ã†ã©ï¼‰

let timeElapsed=0, obstacles=[], frame=0, spawnTimer=0;
const minSpawnIntervalBase=110, maxSpawnIntervalBase=160, spawnIntervalReductionPerSec=4;

/* åºç›¤ã®å¯†åº¦ã‚†ã‚‹ã‚ï¼ˆè»½ã‚ï¼‰ */
const EARLY_EASE_MS = 15_000;
const EARLY_EASE_START_MULT = 1.15;
const EARLY_MAX_ONSCREEN_OBS_MS = 12_000;
const EARLY_MAX_ONSCREEN_OBS = 5;

let isGameOver=false, isPaused=false, gameStarted=false, lastTime=0;
const groundY = gameHeight - 50;

/* â˜… ãƒ‡ãƒãƒƒã‚°ï¼ˆå¾©æ´»ï¼‰ï¼šãƒãƒ¼ã‚ºä¸­ã«5å›ã§ç„¡æ•µON */
let isDebug=false;
let debugTapCount=0;
const DEBUG_TAPS_TO_ENABLE = 5;

let nextSpawnInterval=90;

function clamp01(v){ return Math.max(0, Math.min(1, v)); }
function getEarlyEaseMultiplier(ms){ const t=clamp01(ms/EARLY_EASE_MS); return EARLY_EASE_START_MULT + (1.0 - EARLY_EASE_START_MULT) * t; }
function getMinPixelGap(ms){ const t=clamp01(ms/EARLY_EASE_MS); const start=240, end=160; return Math.round(start + (end - start) * t); }

/* ãƒ‡ãƒãƒƒã‚°ON/OFF */
function enableDebugMode(){
  if(isDebug) return;
  isDebug = true;
  const badge = document.createElement('span');
  badge.id = 'debugBadge';
  badge.textContent = 'DEBUG';
  badge.className = 'px-2 py-1 bg-pink-600 text-white text-xs font-bold rounded shadow-sm ml-1';
  highScoreEl.parentElement.appendChild(badge);
}
function resetDebugTapCounter(){ debugTapCount = 0; }

const player={x:50,y:groundY-50,width:50,height:50,dy:0,gravity:0.8,jumpForce:15,isGrounded:true,jumpsRemaining:2,isJumping:false,image:new Image(),imageLoaded:false};
player.image.src='./assets/Muru.png';
player.image.onload=()=>{player.imageLoaded=true;player.width=(player.image.width/player.image.height)*player.height;};

function drawPlayer(){ if(player.imageLoaded) ctx.drawImage(player.image,player.x,player.y,player.width,player.height); else { ctx.fillStyle='green'; ctx.fillRect(player.x,player.y,player.width,player.height); } }
function updatePlayer(d){
  if(!player.isGrounded){ player.dy+=player.gravity*d; player.y+=player.dy*d; }
  if(player.y+player.height>=groundY){ player.y=groundY-player.height; player.dy=0; player.isGrounded=true; player.jumpsRemaining=2; }
}
function playerJump(){ startAudio(); if(isGameOver||isPaused||!gameStarted) return; if(player.jumpsRemaining>0){ player.dy=-player.jumpForce; player.isGrounded=false; player.isJumping=true; player.jumpsRemaining--; } }
function stopJump(){ if(player.isJumping && player.dy<0){ player.dy=Math.max(player.dy,-5); } player.isJumping=false; }

class Obstacle{
  constructor(type,img,y,size){
    this.x=gameWidth; this.y=y; this.type=type; this.img=img; this.height=size;
    const iw=img.naturalWidth||1, ih=img.naturalHeight||1, aspect=iw/ih;
    this.width=this.height*aspect; this.passed=false;
  }
  draw(){ ctx.drawImage(this.img,this.x,this.y-this.height,this.width,this.height); }
  update(d){ this.x -= gameSpeed*d; }
  getHitbox(){ const shrink=this.type==='ground_large'?0.65:0.8; const w=this.width*shrink,h=this.height*shrink;
    return { x:this.x+(this.width-w)/2, y:(this.y-this.height)+(this.height-h)/2, width:w, height:h }; }
}

const SCALE=0.7;
function spawnObstacle(delta){
  spawnTimer += delta;

  let minSpawnInterval = Math.max(minSpawnIntervalBase - (timeElapsed/1000)*spawnIntervalReductionPerSec, 40);
  let maxSpawnInterval = Math.max(maxSpawnIntervalBase - (timeElapsed/1000)*spawnIntervalReductionPerSec, 70);

  const easeMul = getEarlyEaseMultiplier(timeElapsed);
  minSpawnInterval *= easeMul; maxSpawnInterval *= easeMul;

  if(spawnTimer < nextSpawnInterval) return;

  if(timeElapsed < EARLY_MAX_ONSCREEN_OBS_MS){
    const onscreen = obstacles.filter(o=>o.x + o.width > 0).length;
    if(onscreen >= EARLY_MAX_ONSCREEN_OBS) return;
  }

  const last = obstacles.length ? obstacles[obstacles.length-1] : null;
  const minGapPx = getMinPixelGap(timeElapsed);
  if(last){
    const gapPx = gameWidth - (last.x + last.width);
    if(gapPx < minGapPx) return;
  }

  const rand = Math.random();
  if(rand < 0.4){
    const size = (40 + Math.random()*20) * SCALE;
    const yPos = Math.random() < 0.3 ? groundY - 30 : groundY - 70 - Math.random()*50;
    obstacles.push(new Obstacle('air', SPRITES.blueberry, yPos, size));
  }else{
    if(score > 10 && Math.random() < 0.3){
      obstacles.push(new Obstacle('ground_large', SPRITES.sunflower, groundY, 120*SCALE*1.25));
    }else{
      const size = (60 + Math.random()*20) * SCALE;
      obstacles.push(new Obstacle('ground', SPRITES.sunflower, groundY, size));
    }
  }

  nextSpawnInterval = minSpawnInterval + Math.random()*(maxSpawnInterval - minSpawnInterval);
  spawnTimer = 0;
}

function updateObstacles(d){
  for(let i=obstacles.length-1;i>=0;i--){
    obstacles[i].update(d);
    obstacles[i].draw();
    if(obstacles[i].x + obstacles[i].width < 0) obstacles.splice(i,1);
  }
}

function checkCollision(){
  if(isDebug) return; // ç„¡æ•µ
  const p={x:player.x,y:player.y,width:player.width*0.6,height:player.height*0.7};
  for(const o of obstacles){
    const h=o.getHitbox();
    if(p.x<h.x+h.width && p.x+p.width>h.x && p.y<h.y+h.height && p.y+p.height>h.y){ gameOver(); return; }
  }
}

/* â˜… é€Ÿåº¦ã¯ä¸Šé™ã§æ‰“ã¡æ­¢ã‚ã€‚ä»¥é™ã¯å¯†åº¦ã¨é›†ä¸­åŠ›å‹è² ã€‚ */
function updateScore(){
  for(const o of obstacles){ if(!o.passed && o.x+o.width < player.x){ score++; o.passed=true; } }
  scoreEl.textContent = score;
  const tSec = timeElapsed/1000;
  gameSpeed = Math.min(baseGameSpeed + tSec*gameSpeedAcceleration, GAME_SPEED_MAX);
}

function clearCanvas(){ ctx.clearRect(0,0,gameWidth,gameHeight); }
function drawGround(){ ctx.fillStyle='#8B4513'; ctx.fillRect(0,groundY,gameWidth,gameHeight-groundY); }
function buildXIntentUrl(score){ const text=`ã‚€ã‚‹ã ã£ã—ã‚…ï¼ã‚¹ã‚³ã‚¢ã¯ã€Œ${score}ã€ã§ã—ãŸğŸŒ»\nhttps://t4l-ovo-t4l.github.io/murudash/`; return `https://x.com/intent/tweet?text=${encodeURIComponent(text)}`; }

function gameOver(){
  if(isGameOver) return;
  isGameOver=true; gameStarted=false;
  if(audioStarted){ try{ bgmAudio.pause(); bgmAudio.currentTime=0; endAudio.currentTime=0; endAudio.play(); }catch(_){} }
  if(score>highScore){ highScore=score; localStorage.setItem('muruHighScore',highScore); highScoreEl.textContent=`ãƒã‚¤ã‚¹ã‚³ã‚¢: ${highScore}`; }
  finalScoreEl.textContent=score; shareButton.href=buildXIntentUrl(score);
  gameOverScreen.classList.remove('hidden'); gameOverScreen.classList.add('flex');
}

function restartGame(){
  startAudio(); try{ if(bgmAudio){ bgmAudio.currentTime=0; bgmAudio.play(); } }catch(_){}
  score=0; scoreEl.textContent=score; timeElapsed=0; gameSpeed=baseGameSpeed;
  obstacles=[]; frame=0; spawnTimer=0; isGameOver=false; isPaused=false; gameStarted=true;
  player.y=groundY-player.height; player.dy=0; player.isGrounded=true; player.jumpsRemaining=2;
  gameOverScreen.classList.add('hidden'); gameOverScreen.classList.remove('flex'); pauseOverlay.classList.add('hidden');

  // æ›²é€£å‹•ã®çŠ¶æ…‹ã‚‚ãƒªã‚»ãƒƒãƒˆã—ã¦æœã‚¹ã‚¿ãƒ¼ãƒˆ
  resetAudioSyncState();

  // ãƒ‡ãƒãƒƒã‚°è§£é™¤ï¼†ãƒãƒƒã‚¸é™¤å»
  isDebug = false; resetDebugTapCounter();
  const dbg = document.getElementById('debugBadge'); if(dbg) dbg.remove();

  // ã‚¹ãƒãƒ¼ãƒ³åˆæœŸåŒ–
  spawnTimer=0;
  nextSpawnInterval = minSpawnIntervalBase + Math.random()*(maxSpawnIntervalBase - minSpawnIntervalBase);

  lastTime=performance.now(); requestAnimationFrame(gameLoop);
}

function togglePause(){
  if(isGameOver||!gameStarted) return;
  isPaused=!isPaused;
  if(isPaused){
    try{ if(bgmAudio)bgmAudio.pause(); }catch(_){}
    pauseOverlay.classList.remove('hidden'); pauseOverlay.classList.add('flex');
    resetDebugTapCounter();
  }else{
    try{ if(bgmAudio)bgmAudio.play(); }catch(_){}
    pauseOverlay.classList.add('hidden'); pauseOverlay.classList.remove('flex');
    lastTime=performance.now(); requestAnimationFrame(gameLoop);
    resetDebugTapCounter();
  }
}

function gameLoop(ts){
  if(isGameOver||isPaused||!gameStarted) return;
  const dt = ts - lastTime; lastTime = ts;
  const df = dt / (1000/60);
  timeElapsed += dt;

  // æ›²ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã«åˆã‚ã›ã¦ç©ºã‚’åˆ¶å¾¡
  updateSkyByMusic();

  clearCanvas(); drawSky(df); drawClouds(df);
  drawGround(); updatePlayer(df); drawPlayer();
  spawnObstacle(df); updateObstacles(df); checkCollision(); updateScore();
  frame++; requestAnimationFrame(gameLoop);
}

/* ===== å…¥åŠ› ===== */
window.addEventListener('keydown', e=>{
  if(e.repeat) return;

  // â˜…ãƒãƒ¼ã‚ºä¸­ï¼šã‚¹ãƒšãƒ¼ã‚¹/â†‘ã‚­ãƒ¼5å›ã§ãƒ‡ãƒãƒƒã‚°ON
  if(isPaused && (e.code==='Space' || e.code==='ArrowUp')){
    debugTapCount++;
    if(debugTapCount >= DEBUG_TAPS_TO_ENABLE){ enableDebugMode(); resetDebugTapCounter(); }
    return;
  }

  if(!gameStarted) return;
  if(e.code==='Space'||e.code==='ArrowUp') playerJump();
  if(e.code==='KeyP') togglePause();
});
window.addEventListener('keyup', e=>{ if(e.code==='Space'||e.code==='ArrowUp') stopJump(); });

// ã‚¿ãƒƒãƒ/ã‚¯ãƒªãƒƒã‚¯ãƒœã‚¿ãƒ³å´ã§ã‚‚åŒã˜ãƒˆãƒªã‚¬
jumpButton.addEventListener('pointerdown', e=>{
  e.preventDefault();
  if(isPaused){
    debugTapCount++;
    if(debugTapCount >= DEBUG_TAPS_TO_ENABLE){ enableDebugMode(); resetDebugTapCounter(); }
    return;
  }
  playerJump();
});
jumpButton.addEventListener('pointerup',   e=>{ e.preventDefault(); stopJump(); });

pauseButton.addEventListener('click', e=>{ e.preventDefault(); togglePause(); });
pauseButton.addEventListener('touchstart', e=>{ e.preventDefault(); togglePause(); });

restartButton.addEventListener('click', e=>{ e.preventDefault(); restartGame(); });
restartButton.addEventListener('touchstart', e=>{ e.preventDefault(); restartGame(); });

function handleGameStart(e){
  e.preventDefault();
  if(gameStarted) return;
  gameStarted = true;
  startAudio();
  startScreen.classList.add('hidden');

  // æœã‹ã‚‰é–‹å§‹ & é€£å‹•çŠ¶æ…‹åˆæœŸåŒ–
  resetAudioSyncState();

  // ãƒ‡ãƒãƒƒã‚°è§£é™¤ï¼†ãƒãƒƒã‚¸é™¤å»ï¼ˆä¿é™ºï¼‰
  isDebug = false; resetDebugTapCounter();
  const dbg = document.getElementById('debugBadge'); if(dbg) dbg.remove();

  lastTime = performance.now();
  requestAnimationFrame(gameLoop);
  nextSpawnInterval = minSpawnIntervalBase + Math.random()*(maxSpawnIntervalBase - minSpawnIntervalBase);
  spawnTimer = 0;
}
startButton.addEventListener('click', handleGameStart);
startButton.addEventListener('touchstart', handleGameStart);
</script>
</body>
</html>
